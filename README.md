# ‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏î‡∏±‡∏Å‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ä‡∏∑‡πâ‡∏ô

## ‡∏Ñ‡∏≥‡∏≠‡∏ò‡∏¥‡∏ö‡∏≤‡∏¢‡πÇ‡∏î‡∏¢‡∏¢‡πà‡∏≠
‡πÇ‡∏Ñ‡πâ‡∏î‡∏ô‡∏µ‡πâ‡∏Ñ‡∏∑‡∏≠‡πÇ‡∏õ‡∏£‡πÅ‡∏Å‡∏£‡∏°‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ö‡∏≠‡∏£‡πå‡∏î **ESP32** ‡∏´‡∏£‡∏∑‡∏≠ **ESP8266** (‡πÑ‡∏°‡πÇ‡∏Ñ‡∏£‡∏Ñ‡∏≠‡∏ô‡πÇ‡∏ó‡∏£‡∏•‡πÄ‡∏•‡∏≠‡∏£‡πå‡∏ó‡∏µ‡πà‡∏°‡∏µ WiFi) ‡∏ó‡∏µ‡πà‡∏≠‡∏≠‡∏Å‡πÅ‡∏ö‡∏ö‡∏°‡∏≤‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏Ñ‡∏ß‡∏ö‡∏Ñ‡∏∏‡∏°‡∏û‡∏±‡∏î‡∏•‡∏°‡∏´‡∏£‡∏∑‡∏≠‡∏≠‡∏∏‡∏õ‡∏Å‡∏£‡∏ì‡πå‡∏≠‡∏∑‡πà‡∏ô ‡πÜ ‡∏ú‡πà‡∏≤‡∏ô‡∏£‡∏µ‡πÄ‡∏•‡∏¢‡πå ‡πÇ‡∏î‡∏¢‡∏≠‡πà‡∏≤‡∏ô‡∏Ñ‡πà‡∏≤‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ä‡∏∑‡πâ‡∏ô‡∏à‡∏≤‡∏Å‡πÄ‡∏ã‡πá‡∏ô‡πÄ‡∏ã‡∏≠‡∏£‡πå **DHT11** ‡πÅ‡∏•‡∏∞‡∏£‡∏±‡∏ö‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á/‡∏™‡πà‡∏á‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏ú‡πà‡∏≤‡∏ô **Discord** (Bot)

---

## ‡∏™‡πà‡∏ß‡∏ô‡∏ï‡πà‡∏≤‡∏á ‡πÜ ‡∏Ç‡∏≠‡∏á‡πÇ‡∏Ñ‡πâ‡∏î

### 1. ‡∏Å‡∏≤‡∏£‡∏ô‡∏≥‡πÄ‡∏Ç‡πâ‡∏≤‡πÑ‡∏•‡∏ö‡∏£‡∏≤‡∏£‡∏µ‡πÅ‡∏•‡∏∞‡∏Å‡∏≤‡∏£‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏Ñ‡πà‡∏≤‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô (Includes & Configuration)
- ‡∏ô‡∏≥‡πÄ‡∏Ç‡πâ‡∏≤‡πÑ‡∏•‡∏ö‡∏£‡∏≤‡∏£‡∏µ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö:
  - WiFi, HTTP/HTTPS (‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠ Discord)
  - WiFiManager (‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ WiFi ‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥)
  - ArduinoJson (‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£ JSON)
  - DHT (‡πÄ‡∏ã‡∏ô‡πÄ‡∏ã‡∏≠‡∏£‡πå‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ä‡∏∑‡πâ‡∏ô/‡∏≠‡∏∏‡∏ì‡∏´‡∏†‡∏π‡∏°‡∏¥ DHT11)
- ‡πÉ‡∏ä‡πâ `#ifdef` ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÑ‡∏•‡∏ö‡∏£‡∏≤‡∏£‡∏µ‡∏ó‡∏µ‡πà‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏™‡∏°‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö ESP32 / ESP8266

**‡∏Ñ‡πà‡∏≤‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏™‡∏≥‡∏Ñ‡∏±‡∏ç**
- `RELAY_PIN` (32) ‚Äî ‡∏Ç‡∏≤ GPIO ‡∏ó‡∏µ‡πà‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏Å‡∏±‡∏ö‡∏£‡∏µ‡πÄ‡∏•‡∏¢‡πå‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Ñ‡∏ß‡∏ö‡∏Ñ‡∏∏‡∏°‡∏û‡∏±‡∏î‡∏•‡∏° (Active LOW: LOW = ON, HIGH = OFF)
- `DHTPIN` (14), `DHTTYPE` (DHT11) ‚Äî ‡∏Ç‡∏≤ GPIO ‡πÅ‡∏•‡∏∞‡∏ä‡∏ô‡∏¥‡∏î‡πÄ‡∏ã‡∏ô‡πÄ‡∏ã‡∏≠‡∏£‡πå DHT

**Discord Configuration**
- `discord_token` ‚Äî ‡∏ß‡∏≤‡∏á Token ‡∏Ç‡∏≠‡∏á Discord bot
- `channel_id` ‚Äî ‡∏ß‡∏≤‡∏á Discord Channel ID
- `mentor_user_id` ‚Äî (‡∏ñ‡πâ‡∏≤‡∏°‡∏µ) ID ‡∏Ç‡∏≠‡∏á‡∏ú‡∏π‡πâ‡∏£‡∏±‡∏ö‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô

---

### 2. ‡∏ï‡∏±‡∏ß‡πÅ‡∏õ‡∏£‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡πÅ‡∏•‡∏∞‡πÄ‡∏ß‡∏•‡∏≤ (State & Timing Variables)

**State Variables**
- `fanState`: ‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏û‡∏±‡∏î‡∏•‡∏°‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£ (true/false) ‚Äî ‡πÉ‡∏ä‡πâ‡∏ó‡∏±‡πâ‡∏á‡πÇ‡∏´‡∏°‡∏î Manual ‡∏´‡∏£‡∏∑‡∏≠ Auto
- `autoMode`: ‡πÇ‡∏´‡∏°‡∏î‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥ (‡∏Ñ‡∏ß‡∏ö‡∏Ñ‡∏∏‡∏°‡∏î‡πâ‡∏ß‡∏¢‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ä‡∏∑‡πâ‡∏ô)
- `overheatMode`: ‡πÇ‡∏´‡∏°‡∏î‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô‡∏Ñ‡∏ß‡∏≤‡∏°‡∏£‡πâ‡∏≠‡∏ô‡∏™‡∏π‡∏á (Overheat Protection)
- `lastMessageId`: ‡πÄ‡∏Å‡πá‡∏ö ID ‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏° Discord ‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô‡∏Å‡∏≤‡∏£‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡∏ã‡πâ‡∏≥

**Timing Variables**
- `discordInterval` = 3000 ms (3 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ) ‚Äî ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏à‡∏≤‡∏Å Discord
- `autoInterval` = 2000 ms (2 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ) ‚Äî ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ñ‡πà‡∏≤‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ä‡∏∑‡πâ‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Auto Mode

**Overheat Protection (Duty Cycle)**
- `MAX_RUN_TIME` = 600000 ms = 10 ‡∏ô‡∏≤‡∏ó‡∏µ ‚Äî ‡πÄ‡∏ß‡∏•‡∏≤‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î‡∏ó‡∏µ‡πà‡∏û‡∏±‡∏î‡∏•‡∏°‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏ï‡πà‡∏≠‡πÄ‡∏ô‡∏∑‡πà‡∏≠‡∏á‡πÑ‡∏î‡πâ
- `REST_TIME` = 60000 ms = 1 ‡∏ô‡∏≤‡∏ó‡∏µ ‚Äî ‡πÄ‡∏ß‡∏•‡∏≤‡∏û‡∏±‡∏Å‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÄ‡∏Ç‡πâ‡∏≤‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏û‡∏±‡∏Å (force OFF)

---

### 3. ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏∑‡πà‡∏≠‡∏™‡∏≤‡∏£‡∏Å‡∏±‡∏ö Discord (Discord Communication Functions)

#### `sendDiscordMessage(String message)`
- ‡πÉ‡∏ä‡πâ HTTP POST ‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡πÑ‡∏õ‡∏¢‡∏±‡∏á Discord channel ‡∏ó‡∏µ‡πà‡∏Å‡∏≥‡∏´‡∏ô‡∏î
- ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞ WiFi ‡∏Å‡πà‡∏≠‡∏ô‡∏™‡πà‡∏á
- ‡πÉ‡∏ä‡πâ `WiFiClientSecure` + `client.setInsecure()` (‡πÑ‡∏°‡πà‡∏õ‡∏•‡∏≠‡∏î‡∏†‡∏±‡∏¢‡πÉ‡∏ô‡πÄ‡∏ä‡∏¥‡∏á‡∏Ñ‡∏ß‡∏≤‡∏°‡∏°‡∏±‡πà‡∏ô‡∏Ñ‡∏á)
- ‡∏™‡∏£‡πâ‡∏≤‡∏á payload ‡πÄ‡∏õ‡πá‡∏ô JSON ‡∏î‡πâ‡∏ß‡∏¢ `StaticJsonDocument` ‡πÅ‡∏•‡πâ‡∏ß `serializeJson`

#### `checkDiscordCommands()`
- ‡πÉ‡∏ä‡πâ HTTP GET ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î‡∏à‡∏≤‡∏Å Discord (`limit=1`)
- ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö `msgId` ‡∏ß‡πà‡∏≤‡πÅ‡∏ï‡∏Å‡∏ï‡πà‡∏≤‡∏á‡∏à‡∏≤‡∏Å `lastMessageId` ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
- ‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á:
  - `!status` ‚Äî ‡∏ï‡∏≠‡∏ö‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏£‡∏∞‡∏ö‡∏ö (‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ä‡∏∑‡πâ‡∏ô, Auto Mode, Overheat, Fan)
  - `!auto on` / `!auto off` ‚Äî ‡πÄ‡∏õ‡∏¥‡∏î/‡∏õ‡∏¥‡∏î Auto Mode
  - `!overheat on` / `!overheat off` ‚Äî ‡πÄ‡∏õ‡∏¥‡∏î/‡∏õ‡∏¥‡∏î Overheat Protection
  - `!fan on` / `!fan off` ‚Äî ‡∏Ñ‡∏ß‡∏ö‡∏Ñ‡∏∏‡∏°‡∏û‡∏±‡∏î‡∏•‡∏°‡πÅ‡∏ö‡∏ö Manual (‡πÉ‡∏ä‡πâ‡πÑ‡∏î‡πâ‡πÄ‡∏°‡∏∑‡πà‡∏≠ `autoMode` = OFF)

---

### 4. ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏Ñ‡∏ß‡∏ö‡∏Ñ‡∏∏‡∏°‡∏û‡∏±‡∏î‡∏•‡∏° (`runFanLogic`)
- ‡∏ó‡∏≥‡∏´‡∏ô‡πâ‡∏≤‡∏ó‡∏µ‡πà‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏™‡∏∏‡∏î‡∏ó‡πâ‡∏≤‡∏¢‡∏Ç‡∏≠‡∏á‡∏£‡∏µ‡πÄ‡∏•‡∏¢‡πå (‡∏û‡∏±‡∏î‡∏•‡∏°)
- **Auto Mode Logic**:
  - ‡πÄ‡∏°‡∏∑‡πà‡∏≠ `autoMode` = ON ‡∏à‡∏∞‡∏≠‡πà‡∏≤‡∏ô‡∏Ñ‡πà‡∏≤‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ä‡∏∑‡πâ‡∏ô‡∏ó‡∏∏‡∏Å `autoInterval`
  - ‡∏´‡∏≤‡∏Å‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ä‡∏∑‡πâ‡∏ô > 60.0% ‚Üí ‡∏™‡∏±‡πà‡∏á‡∏û‡∏±‡∏î‡∏•‡∏° ON
  - ‡∏°‡∏¥‡∏â‡∏∞‡∏ô‡∏±‡πâ‡∏ô ‚Üí OFF
- **Overheat Protection Logic (Duty Cycle)**:
  - ‡∏´‡∏≤‡∏Å‡∏û‡∏±‡∏î‡∏•‡∏°‡∏ñ‡∏π‡∏Å‡∏™‡∏±‡πà‡∏á ON ‡πÅ‡∏•‡∏∞ `overheatMode` = ON:
    - ‡∏´‡∏≤‡∏Å‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏ï‡πà‡∏≠‡πÄ‡∏ô‡∏∑‡πà‡∏≠‡∏á‡∏Ñ‡∏£‡∏ö `MAX_RUN_TIME` ‚Üí ‡∏™‡∏•‡∏±‡∏ö‡πÄ‡∏õ‡πá‡∏ô‡∏û‡∏±‡∏Å (`isResting = true`) ‡πÅ‡∏•‡∏∞ force OFF ‡πÄ‡∏õ‡πá‡∏ô‡πÄ‡∏ß‡∏•‡∏≤ `REST_TIME`
    - ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏û‡∏±‡∏Å‡∏Ñ‡∏£‡∏ö ‚Üí ‡∏Å‡∏•‡∏±‡∏ö‡∏°‡∏≤‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏ï‡πà‡∏≠
  - ‡∏´‡∏≤‡∏Å‡∏û‡∏±‡∏î‡∏•‡∏° OFF ‡∏´‡∏£‡∏∑‡∏≠ `overheatMode` = OFF ‚Üí ‡∏£‡∏µ‡πÄ‡∏ã‡πá‡∏ï‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô‡∏Ñ‡∏ß‡∏≤‡∏°‡∏£‡πâ‡∏≠‡∏ô
- **Hardware Actuation**:
  - ‡∏£‡∏µ‡πÄ‡∏•‡∏¢‡πå‡πÄ‡∏õ‡πá‡∏ô Active LOW: ‡πÉ‡∏ä‡πâ `digitalWrite(RELAY_PIN, finalRelayState ? LOW : HIGH);`

---

### 5. ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô `setup()` ‡πÅ‡∏•‡∏∞ `loop()`
- `setup()`:
  - ‡πÄ‡∏£‡∏¥‡πà‡∏° Serial
  - ‡∏ï‡∏±‡πâ‡∏á `RELAY_PIN` ‡πÄ‡∏õ‡πá‡∏ô OUTPUT ‡πÅ‡∏•‡∏∞‡πÄ‡∏ã‡πá‡∏ï HIGH (‡∏û‡∏±‡∏î‡∏•‡∏° OFF)
  - ‡πÄ‡∏£‡∏¥‡πà‡∏° DHT sensor
  - ‡πÉ‡∏ä‡πâ `WiFiManager` ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏° WiFi ‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥ (‡∏™‡∏£‡πâ‡∏≤‡∏á AP ‡∏´‡∏≤‡∏Å‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡πÄ‡∏Ñ‡∏¢‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°)
  - ‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏° "System Online" ‡πÑ‡∏õ‡∏¢‡∏±‡∏á Discord
- `loop()`:
  - ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å `runFanLogic()` ‡πÄ‡∏õ‡πá‡∏ô‡∏£‡∏∞‡∏¢‡∏∞
  - ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö `checkDiscordCommands()` ‡∏ó‡∏∏‡∏Å `discordInterval`

---
![IMG_20260213_143531](IMG_20260213_143531.jpg)
![IMG_20260213_143549](IMG_20260213_143549.jpg)
![IMG_20260216_095204](IMG_20260216_095204.jpg)
![IMG_20260216_105318](IMG_20260216_105318.jpg)
![IMG_20260216_105332](IMG_20260216_105332.jpg)

## ‡πÇ‡∏Ñ‡πâ‡∏î (‡πÄ‡∏ï‡πá‡∏°)
```cpp
#ifdef ESP32
 #include <WiFi.h>
 #include <HTTPClient.h>
 #include <WiFiClientSecure.h>
#elif defined(ESP8266)
 #include <ESP8266WiFi.h>
 #include <ESP8266HTTPClient.h>
 #include <WiFiClientSecure.h>
#endif

#include <WiFiManager.h>
#include <ArduinoJson.h>
#include "DHT.h"

// --- Configuration ---
#define RELAY_PIN 32
#define DHTPIN 14
#define DHTTYPE DHT11

// Discord Configuration
const char* discord_token = "‡∏ß‡∏≤‡∏á Token Discord bot";
const char* channel_id = "‡∏ß‡∏≤‡∏á Discord Channel ID";
const char* mentor_user_id = "‡∏ß‡∏≤‡∏á ID ‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏ô‡∏ó‡∏µ‡πà‡πÄ‡∏õ‡πá‡∏ô‡πÄ‡∏à‡πâ‡∏≤‡∏Ç‡∏≠‡∏á‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô";

DHT dht(DHTPIN, DHTTYPE);

// --- State Variables ---
bool fanState = false;          // Desired Fan State (Manual or Auto decision)
bool autoMode = false;          // Auto Mode (Humidity Control)
bool overheatMode = false;      // Overheat Protection Mode
String lastMessageId = "";

// --- Timing Variables ---
unsigned long lastDiscordCheck = 0;
const long discordInterval = 3000;

// Overheat Protection Variables
unsigned long currentRunStartTime = 0;
bool isResting = false;
unsigned long restStartTime = 0;
const unsigned long MAX_RUN_TIME = 600000; // 10 minutes
const unsigned long REST_TIME = 60000;     // 1 minute

// Auto Mode Timer
unsigned long lastAutoCheck = 0;
const long autoInterval = 2000;

void sendDiscordMessage(String message) {
 if (WiFi.status() != WL_CONNECTED) return;
 HTTPClient http;
 WiFiClientSecure client;
 client.setInsecure();
 if (http.begin(client, String("https://discord.com/api/v10/channels/") + channel_id + "/messages")) {
   http.addHeader("Authorization", String("Bot ") + discord_token);
   http.addHeader("Content-Type", "application/json");
   StaticJsonDocument<512> doc;
   doc["content"] = message;
   String jsonBody;
   serializeJson(doc, jsonBody);
   int httpCode = http.POST(jsonBody);
   if (httpCode > 0) Serial.printf("[Discord] Sent: %d\n", httpCode);
   else Serial.printf("[Discord] Error: %s\n", http.errorToString(httpCode).c_str());
   http.end();
 }
}

void checkDiscordCommands() {
 if (WiFi.status() != WL_CONNECTED) return;
 HTTPClient http;
 WiFiClientSecure client;
 client.setInsecure();
  if (http.begin(client, String("https://discord.com/api/v10/channels/") + channel_id + "/messages?limit=1")) {
   http.addHeader("Authorization", String("Bot ") + discord_token);
   int httpCode = http.GET();
   if (httpCode == 200) {
     String payload = http.getString();
     DynamicJsonDocument doc(2048);
     DeserializationError error = deserializeJson(doc, payload);
     if (!error && doc.size() > 0) {
       String msgContent = doc[0]["content"].as<String>();
       String msgId = doc[0]["id"].as<String>();
      
       if (msgId != lastMessageId) {
         lastMessageId = msgId;
         msgContent.toLowerCase();
         Serial.println("[Discord] Cmd: " + msgContent);

         if (msgContent.indexOf("!status") >= 0) {
            float h = dht.readHumidity();
            String statusMsg = "üìä **System Status**\n";
            statusMsg += "üå°Ô∏è Humidity: **" + String(h, 1) + "%**\n";
            statusMsg += "ü§ñ Auto Mode: **" + String(autoMode ? "ON" : "OFF") + "**\n";
            statusMsg += "üõ°Ô∏è Overheat Protection: **" + String(overheatMode ? "ON" : "OFF") + "**\n";
            statusMsg += "‚ùÑÔ∏è Fan State: **" + String(digitalRead(RELAY_PIN) == LOW ? "ON" : "OFF") + "**";
            if (overheatMode && isResting) statusMsg += " (recovering...)";
            sendDiscordMessage(statusMsg);
         }
         else if (msgContent.indexOf("!auto on") >= 0) {
           autoMode = true;
           sendDiscordMessage("ü§ñ Auto Mode: **ON** (Fan controlled by humidity > 60%)");
         }
         else if (msgContent.indexOf("!auto off") >= 0) {
           autoMode = false;
           sendDiscordMessage("ü§ñ Auto Mode: **OFF** (Manual control enabled)");
         }
         else if (msgContent.indexOf("!overheat on") >= 0) {
           overheatMode = true;
           currentRunStartTime = millis(); // Reset timer
           isResting = false;
           sendDiscordMessage("üõ°Ô∏è Overheat Protection: **ON** (10m ON / 1m OFF cycle enabled)");
         }
         else if (msgContent.indexOf("!overheat off") >= 0) {
           overheatMode = false;
           isResting = false;
           sendDiscordMessage("'Ô∏è Overheat Protection: **OFF**");
         }
         else if (msgContent.indexOf("!fan on") >= 0) {
           if (autoMode) {
              sendDiscordMessage("‚ö†Ô∏è Cannot manually control fan while **Auto Mode** is ON. Disable auto mode first (!auto off).");
           } else {
              fanState = true;
              sendDiscordMessage("‚úÖ Manual Fan: **ON**");
           }
         }
         else if (msgContent.indexOf("!fan off") >= 0) {
           if (autoMode) {
              sendDiscordMessage("‚ö†Ô∏è Cannot manually control fan while **Auto Mode** is ON. Disable auto mode first (!auto off).");
           } else {
              fanState = false;
              sendDiscordMessage("üõë Manual Fan: **OFF**");
           }
         }
       }
     }
   }
   http.end();
 }
}

void runFanLogic() {
 // 1. Determine Desired State
 bool desiredState = fanState;

 // Auto Mode Logic
 if (autoMode) {
   if (millis() - lastAutoCheck > autoInterval) {
     lastAutoCheck = millis();
     float h = dht.readHumidity();
     if (!isnan(h)) {
       if (h > 60.0) {
          desiredState = true;
          // If we just switched to ON from OFF in auto mode
          if (!fanState) {
            fanState = true;
            // Optional: Notify? sendDiscordMessage("üíß Humidity > 60%. Auto Fast Start.");
          }
       } else {
          desiredState = false;
          if (fanState) { fanState = false; }
       }
     }
   }
   desiredState = fanState; // Sync local var
 }

 // 2. Apply Overheat Protection Logic (Duty Cycle)
 bool finalRelayState = desiredState; // True = ON (LOW)

 if (desiredState && overheatMode) {
   unsigned long now = millis();
   if (!isResting) {
      if (now - currentRunStartTime >= MAX_RUN_TIME) {
         isResting = true;
         restStartTime = now;
         finalRelayState = false; // Force OFF
         sendDiscordMessage("üõ°Ô∏è Overheat Protection: Resting for 1 minute...");
      }
   } else {
      if (now - restStartTime >= REST_TIME) {
         isResting = false;
         currentRunStartTime = now;
         finalRelayState = true; // Resume ON
         sendDiscordMessage("üõ°Ô∏è Overheat Protection: Resuming operation.");
      } else {
         finalRelayState = false; // Keep OFF
      }
   }
 } else {
   // If fan is OFF or Overheat protection disabled, reset protection state
   if (!desiredState) {
      currentRunStartTime = millis();
      isResting = false;
   }
 }

 // 3. Hardware Actuation
 // Relay is Active LOW (LOW = ON, HIGH = OFF)
 digitalWrite(RELAY_PIN, finalRelayState ? LOW : HIGH);
}

void setup() {
 Serial.begin(115200);
 pinMode(RELAY_PIN, OUTPUT);
 digitalWrite(RELAY_PIN, HIGH); // Default OFF
 dht.begin();
 WiFiManager wm;
 if (!wm.autoConnect("ESP32_Peltier_Control")) ESP.restart();
 Serial.println("Ready!");
 sendDiscordMessage("ü§ñ System Online. waiting for commands...");
}

void loop() {
 runFanLogic();
 if (millis() - lastDiscordCheck > discordInterval) {
   lastDiscordCheck = millis();
   checkDiscordCommands();
 }
}
